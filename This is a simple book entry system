#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include "conio.h"
#define MAX 1024
#define  books "books.txt"
#define  booktow "booktow.txt"

struct Bookinfo
{
	char isbn[20];
	char  tail[40];
	char name[40];
	int count;
};

struct Book
{
	struct Bookinfo onebook;
	struct Book *next;
};

int addbook(struct Bookinfo one,struct Book *firstptr)//
{
	while(firstptr->next!=0)
	{
		firstptr=firstptr->next;
	}
	firstptr->next=(struct Book *)malloc(sizeof(struct Book));
	firstptr->next->onebook=one;
	firstptr->next->next=NULL;
	return 0;
}

void addbooks(struct Book *firstptr,FILE *fp)//
{
	struct Bookinfo one;
	int i;
	printf("ISBN:");
	scanf("%s",one.isbn);
	printf("Title:");
	scanf("%s",one.tail);
	printf("The author:");
	scanf("%s",one.name);
	i=addbook(one,firstptr);
	if(i==0)
	{
		fprintf(fp,"\n%s %s %s %d",one.isbn,one.tail,one.name,0);
		printf("Book entry successful>_<\n");
	}
	else
	{
		printf("Book entry failureT_T\n");
	}	
}

struct Book* query(struct Book *firstptr,char isbnot[])
{
	while(firstptr!=NULL)
	{
		if(strcmp(firstptr->onebook.isbn,isbnot)==0)
			return firstptr;
		else
			firstptr=firstptr->next;
	}
	return NULL;
}

void querybook(struct Book *firstptr)
{
	char isbnot[20];
	FILE *fp;
	struct Book *adk;
	printf("Please enter the ISBN number of the book you are looking for:");
	scanf("%s",&isbnot);	
	adk=query(firstptr,isbnot);
	if(adk!=NULL)
	{
		printf("To find the!!!\n");
		printf("ISBN:%s\n",adk->onebook.isbn);
		printf("Title:%s\n",adk->onebook.tail);
		printf("The author:%s\n",adk->onebook.name);
	}
	else
	{
		printf("I'm sorry, this book is unavailableT_T\n");
	}
	
}

int Modify1(struct Book* firstptr,char ch[],struct Bookinfo onebook,FILE* fp)
{
	char d;
	int i=1;
	while(firstptr!=NULL)
	{
		if(strcmp(firstptr->onebook.isbn,ch)==0)
		{
			printf("Target book found...\n");
			printf("ISBN:%s\n",firstptr->onebook.isbn);
			printf("Title:%s\n",firstptr->onebook.tail);
			printf("The author:%s\n",firstptr->onebook.name);
			printf("Whether to start modifying(y/n):");//�޸���֤ 
			scanf("%s",&d); 
			while(d!='y'&&d!='n')
			{
				printf("Incorrect input, please try again:");
				scanf("%s",&d);
			}
			if(d=='y')
			{
				printf("Please enter a new ISBN number:");
				scanf("%s",onebook.isbn);	 
		    	printf("Please enter a new title:");
				scanf("%s",onebook.tail);	 
				printf("Please enter a new author:");
				scanf("%s",onebook.name);
				firstptr->onebook=onebook;//Stores the modified structure overlay into the linked list node
				printf("Modify the success>_<\n");
			}
			else
				printf("Cancel modification successfully>_<\n");
			i=0;
		}
		fprintf(fp,"%s %s %s %d\n",firstptr->onebook.isbn,firstptr->onebook.tail,firstptr->onebook.name,firstptr->onebook.count);
		//Save the modified linked list overlay to a file,
		firstptr=firstptr->next;
	}
	return i;
}

void Modify(struct Book *firstptr,FILE *fp)
{
	int i,j;
	struct Book* book=firstptr;
	char ch[20];
	struct Bookinfo onebook;
	printf("Please enter the ISBN number of the book you want to modify:");
	scanf("%s",&ch);
	if((fp=fopen(books,"w+"))==NULL)
	{
		printf("File opening failedT_T\n");
		exit(EXIT_FAILURE);
	}
	j=Modify1(firstptr,ch,onebook,fp);
    if(i)
	{
		printf("I'm sorry, this book is unavailableT_T\n");
	 } 
}

int Delete1(struct Book* firstptr,char ch[]) 
{
	while(firstptr!=NULL)
	{
		if(strcmp(firstptr->onebook.isbn,ch)==0)
		{
			firstptr->next=firstptr->next->next;
			return 1;
		}
		else
			firstptr=firstptr->next;
	}
	return 0;
}

void Delete(struct Book *firstptr,FILE *fp)
{
	int i,j;
	struct Book* book=firstptr;
	char ch[20];
	struct Bookinfo onebook;
	printf("Please enter the ISBN number of the book you want to delete:");
	scanf("%s",&ch);
	j=Delete1(firstptr,ch);
	if(j) 
	{ 
		FILE* fpbak;
		if((fpbak=fopen(booktow,"a+"))==NULL)
		{
			printf("File opening failedT_T\n");
			exit(EXIT_FAILURE);
		}
		fseek(fp,0,0);
		while((fscanf(fp,"%s %s %s %d\n",&onebook.isbn,&onebook.tail,&onebook.name,&onebook.count))!=EOF)
		{
			if(strcmp(onebook.isbn,ch)!=0)
				fprintf(fpbak,"%s %s %s %d\n",onebook.isbn,onebook.tail,onebook.name,onebook.count);
		}
		fclose(fp);
		fclose(fpbak);
		if(remove(books))
		{
			printf("File deletion failedT_T\n");
			exit(EXIT_FAILURE);
		}
		else
			if(rename(booktow,books))
			{
				printf("Failed to rename fileT_T\n");
				exit(EXIT_FAILURE);
			}
		printf("Delete the success>_<\n");
	}
	else
	{
		printf("I'm sorry, this book is unavailableT_T\n");
	}
}


int menu()
{
	int ch;
	printf(".................................\n");
	printf("...Welcome to the book entry system\n");
	printf("...1.Add input book information\n");
	printf("...2.Search for Book Information\n");
	printf("...3.Modify book information\n");
	printf("...4.Delete book information\n");
	printf("...5.Exit the book entry system\n");
	printf(".................................\n");
	printf("Please select your operation");
	//scanf("%d",&ch);
	//getch();
	return ch=getchar(); 
	printf("\n\n");
}

int addEntry(struct Book*firstptr,FILE *fp)//Loads the information stored in the file
{
	struct Bookinfo onebook;
	while((fscanf(fp,"%s %s %s %d\n",&onebook.isbn,&onebook.tail,&onebook.name,&onebook.count))!=EOF)
	{
		while(firstptr->next!=0)
			firstptr=firstptr->next;
		firstptr->next=(struct Book *)malloc(sizeof(struct Book));
		firstptr->next->onebook=onebook;
		firstptr->next->next=NULL;
	}
	return 0;
}

int main(void)
{
	struct Book first;
	strcpy(first.onebook.isbn,"123");
	strcpy(first.onebook.tail,"aad");
	strcpy(first.onebook.name,"bbc");
	first.next=NULL;
	struct Book *firstptr=&first;
	int ch;
	FILE *fp;
	if((fp=fopen(books,"a+"))==NULL)
	{
		printf("File opening failedT_T\n");
	    exit(EXIT_FAILURE);
	}
	addEntry(firstptr,fp);
	while(ch!=5)
	{
		system("CLS");
		fflush(stdin); //Cleanup the "\n" left in the buffer by the last getchar()
		fflush(stdout);
		ch=menu()-48;  
		switch(ch)
		{
			case 1:
				addbooks(firstptr,fp);
				break;
			case 2:
				querybook(firstptr);
				break;
			case 3:
				Modify(firstptr,fp); 
				break;
			case 4:
				Delete(firstptr,fp);
				break;
			case 5:
				break;
			default:
				printf("Please enter the correct serial number!");
		}
		system("PAUSE");
	 }
	  
}
  
